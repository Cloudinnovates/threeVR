<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>
      deviceorientation - quaternion &amp; rotation matrix manipulation - w/ three.js
    </title>
    <style type="text/css">
      body {
        background-color: #000000;
        margin: 0;
        overflow: hidden;
      }

      #extra {
        position: fixed;
        width: 100%;
        color: #ffffff;
        padding: 5px;
        font-family: Monospace;
        font-size: 13px;
        font-weight: bold;
        text-align: center;
        z-index: 1;
        bottom: 3px;
      }

      #extra a {
        display: inline-block;
        padding: 2px 5px;
        margin: 2px 5px;
      }

      #controller {
        background-color: #fff;
        color: #000;
        border: 1px solid #000;
        z-index: 2;
      }

      #controllertype {
        background-color: #ccc;
        color: #000;
        border: 1px solid #999;
      }
    </style>
  </head>
  <body>
    <script src="./lib/three.min.js" type="text/javascript"></script>
    <script src="./lib/CSS3DRenderer.js" type="text/javascript"></script>

    <script src="../js/DeviceOrientationController.js" type="text/javascript"></script>

    <div id="extra">
      DeviceOrientation Control: <a id="controllertype" href="#" name="controllertype">Quaternions</a>
    </div>

    <script type="text/javascript">

      var camera, scene, renderer, controls;

      function init() {

        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );

        // Render three.js world

        scene = new THREE.Scene();

        // Choose a random integer from 2 to 3
        var id = Math.floor(Math.random() * (3 - 2 + 1)) + 2;

        var cube = generateCubeMap('Park' + id + 'Small');
        scene.add( cube );

        renderer = new THREE.CSS3DRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        // Initiate our deviceorientation-based controller (with manual drag move overrides)
        controls = new DeviceOrientationController( camera, renderer.domElement );
        controls.connect();

        // Show some e.g. visual effects when the user interacts with the VR viewer
        controls.addEventListener('userinteractionstart', function() {
          renderer.domElement.style.cursor = 'move';
        });
        controls.addEventListener('userinteractionstop', function() {
          renderer.domElement.style.cursor = 'default';
        });

        // TODO: Implement a compass calibration UI when required by the device
        controls.addEventListener('compassneedscalibration', function() {
          alert('Your compass needs calibrating. Wave your phone in a figure 8 motion then continue.');
        });

        // Allow rotation matrix to quaternion switching for this demo
        var switchDeviceModelEl = document.querySelector('#controllertype');

        switchDeviceModelEl.addEventListener('click', function( event ) {
          event.preventDefault();

          if( controls.useQuaternions === true ) {
            switchDeviceModelEl.textContent = 'Rotation Matrix';
            controls.useQuaternions = false;
          } else {
            switchDeviceModelEl.textContent = 'Quaternions';
            controls.useQuaternions = true;
          }
        }, false);

        window.addEventListener( 'resize', onWindowResize, false );

      }

      function generateCubeMap( folderName ) {

        var sides = [
          {
            url: './textures/cube/' + folderName + '/posx.jpg',
            position: [ -512, 0, 0 ],
            rotation: [ 0, Math.PI / 2, 0 ]
          },
          {
            url: './textures/cube/' + folderName + '/negx.jpg',
            position: [ 512, 0, 0 ],
            rotation: [ 0, -Math.PI / 2, 0 ]
          },
          {
            url: './textures/cube/' + folderName + '/posy.jpg',
            position: [ 0,  512, 0 ],
            rotation: [ Math.PI / 2, 0, Math.PI ]
          },
          {
            url: './textures/cube/' + folderName + '/negy.jpg',
            position: [ 0, -512, 0 ],
            rotation: [ - Math.PI / 2, 0, Math.PI ]
          },
          {
            url: './textures/cube/' + folderName + '/posz.jpg',
            position: [ 0, 0,  512 ],
            rotation: [ 0, Math.PI, 0 ]
          },
          {
            url: './textures/cube/' + folderName + '/negz.jpg',
            position: [ 0, 0, -512 ],
            rotation: [ 0, 0, 0 ]
          }
        ];

        var cube = new THREE.Object3D();

        for ( var i = 0; i < sides.length; i ++ ) {

          var side = sides[ i ];

          var element = document.createElement( 'img' );
          element.width = 1026; // 2 pixels extra to close the gap.
          element.src = side.url;

          var object = new THREE.CSS3DObject( element );
          object.position.fromArray( side.position );
          object.rotation.fromArray( side.rotation );
          cube.add( object );

        }

        return cube;

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;

        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function animate() {

        controls.update();

        renderer.render( scene, camera );

        requestAnimationFrame( animate );

      }

      init();
      animate();

    </script>

    <!-- Github Banner -->
    <a href="https://github.com/richtr/threeVR"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
  </body>
</html>
